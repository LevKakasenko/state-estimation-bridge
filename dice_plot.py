"""
Author: Lev Kakasenko
Description:
Plots the Dice coefficients between the sensor locations of one sensor placement 
heuristic (Greedy D-optimal, CPQR, etc.) and another.  For further information on
the Dice coefficient, see "Measures of the Amount of Ecologic Association Between Species"
by Lee R. Dice (1945).

If you use this code in any form, please cite "Bridging the Gap Between Deterministic and
Probabilistic Approaches to State Estimation" by Lev Kakasenko,  Alen Alexanderian,
Mohammad Farazmand, and Arvind Krishna Saibaba (2025)
"""

import random
import numpy as np
import matplotlib.pyplot as plt
from utils import load_data, check_missing_data, generate_heur_key
from data_matrices import turbulence

# Parameters
# Note: These parameters are the same as those in plot_error.py.  Some of these
#       parameters (like plot_type and reconstructors) are immaterial to the plot
#       of dice coefficients generated by this program.  We nonetheless include these
#       parameters to allow for data to be scraped in from the logs.
data_matrix = 'turbulence'
num_features = turbulence().shape[0]
num_samples = turbulence().shape[1]
noise = .3
sigma_noise = noise
split_idx = 750
mode_range = range(5, 101, 5)
sensor_range = range(25, 26) # must have length 1
plot_type = 'error_vs_modes'
heuristics = ['cpqr', 'dopt_greedy'] # must have length 2
reconstructors = [
                'map',
                'map'
                ] # must have length 2
priors = [
          'natural',
          'natural'
          ] # must have length 2
seed = 0


# fix number of sensors
sensors = sensor_range[0]

# Scrape in data from the logs.
log = load_data(heuristics, reconstructors, priors, plot_type, mode_range, 
                sensor_range, num_features, num_samples, split_idx, 
                data_matrix, noise, sigma_noise, seed)

# Check if there is any missing data.
check_missing_data(log=log, heuristics=heuristics, priors=priors, reconstructors=reconstructors, 
                   plot_type=plot_type, mode_range=mode_range, sensor_range=sensor_range)

# set the seed for randomly generated values
random.seed(seed)
np.random.seed(seed)

# initialize the dictionary for storing lists of indices
heur_indices = {}

# populate the dictionary that stores the lists of indices
for idx in range(len(heuristics)):
    heur = heuristics[idx]
    heur_indices[heur] = []
    prior = priors[idx]
    reconstructor = reconstructors[idx]
    heur_key = generate_heur_key(heur, prior, reconstructor)
    log_heur = log[heur_key]

    for modes in mode_range:
        values = log_heur[(modes, sensors)]
        sensor_indices = list(values[0])
        heur_indices[heur].append(sensor_indices)

# initialize list of Dice coefficients
dice_lst = []

# populate list of Dice coefficients
for i in range(len(mode_range)):
    indices1 = heur_indices[heuristics[0]][i]
    indices2 = heur_indices[heuristics[1]][i]
    indices_comb = list(set(indices1 + indices2))
    matches = [((i in indices1) and (i in indices2)) for i in indices_comb]
    
    dice_portion = 2 * sum(matches) / (len(set(indices1)) + len(set(indices2)))
    dice_lst.append(dice_portion)

# plot results
plt.figure(dpi=200)
plt.rcParams['font.family'] = 'Times New Roman'
plt.rcParams['text.usetex'] = True
plt.axvline(x=sensor_range[0], color='black', linestyle='--') # plot vertical dashed axis
#plt.text(sensor_range[0], 1.2, f'sensors = {sensor_range[0]}', fontsize=14, 
#         horizontalalignment='center', color='black')
plt.title(r'$\sigma_{\textrm{noise}}=$ ' + str(sigma_noise), fontsize=14)
plt.plot(mode_range, dice_lst, linestyle='solid', marker='o', markersize=4, linewidth=2)
plt.xlabel('Number of modes', fontsize=14)
plt.ylabel('Dice coefficient', fontsize=14)
plt.tick_params(axis='both', which='major', labelsize=14)
#plt.xticks(range(0, 21, 5))
plt.show()
